#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
GPIO generator module.

Generates coreboot-compatible GPIO configuration files from parsed data.
"""

import logging
from pathlib import Path
from typing import List, Dict
from platforms.alderlake import PadMode

logger = logging.getLogger(__name__)


class GPIOGenerator:
    """Generates coreboot GPIO configuration files"""
    
    def __init__(self, platform='alderlake'):
        """
        Initialize GPIO generator.
        
        Args:
            platform: Platform name
        """
        self.platform = platform
    
    def generate_coreboot_header(self, pads: List[Dict], output_path: Path):
        """
        Generate coreboot-style gpio.h file.
        
        Args:
            pads: List of parsed pad configurations
            output_path: Output file path
        """
        lines = []
        
        # Header
        lines.append("/* SPDX-License-Identifier: GPL-2.0-only */")
        lines.append("")
        lines.append("/* Generated by bios2gpio tool */")
        lines.append("")
        lines.append("#include <soc/gpio.h>")
        lines.append("")
        lines.append("static const struct pad_config gpio_table[] = {")
        
        # Group pads by GPIO group for better organization
        current_group = None
        
        for pad in pads:
            pad_name = pad['name']
            group = pad.get('group', 'UNKNOWN')
            
            # Add group header comment
            if group != current_group:
                if current_group is not None:
                    lines.append("")
                lines.append(f"\t/* ------- GPIO Group {group} ------- */")
                lines.append("")
                current_group = group
            
            # Generate macro for this pad
            macro = self._generate_pad_macro(pad)
            if macro:
                # Add comment with pad name and function
                mode = pad.get('mode', 'GPIO')
                comment = f"\t/* {pad_name} - {mode} */"
                lines.append(comment)
                lines.append(f"\t{macro},")
        
        # Footer
        lines.append("};")
        lines.append("")
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        logger.info(f"Generated coreboot gpio.h at {output_path}")
    
    def _generate_pad_macro(self, pad: Dict) -> str:
        """
        Generate coreboot PAD_CFG_* macro for a single pad.
        
        Args:
            pad: Pad configuration dict
        
        Returns:
            Macro string
        """
        pad_name = pad['name']
        mode = pad.get('mode', 'GPIO')
        direction = pad.get('direction', 'INPUT')
        output_value = pad.get('output_value', 0)
        reset = pad.get('reset', 'PLTRST')
        termination = pad.get('termination', 'NONE')
        interrupt_type = pad.get('interrupt', 'NONE')
        is_vgpio = pad.get('is_vgpio', False)
        
        # Map termination names to coreboot constants
        term_map = {
            'NONE': 'NONE',
            'DN_5K': 'DN_5K',
            'DN_20K': 'DN_20K',
            'UP_1K': 'UP_1K',
            'UP_2K': 'UP_2K',
            'UP_5K': 'UP_5K',
            'UP_20K': 'UP_20K',
            'UP_1K_2K': 'UP_2K',  # Map to UP_2K as UP_1K_2K doesn't exist in coreboot
            'NATIVE': 'NATIVE',
        }
        term = term_map.get(termination, 'NONE')
        
        # VGPIOs use _PAD_CFG_STRUCT format
        if is_vgpio:
            return self._generate_vgpio_struct(pad)
        
        # Generate appropriate macro based on configuration
        if mode == 'GPIO':
            if direction == 'OUTPUT':
                # PAD_CFG_GPO(pad, val, rst)
                return f"PAD_CFG_GPO({pad_name}, {output_value}, {reset})"
            elif direction == 'INPUT':
                if interrupt_type == 'APIC':
                    # PAD_CFG_GPI_APIC(pad, term, rst)
                    return f"PAD_CFG_GPI_APIC_LOW({pad_name}, {term}, {reset})"
                elif interrupt_type == 'SCI':
                    # PAD_CFG_GPI_SCI(pad, term, rst, edge, inv)
                    return f"PAD_CFG_GPI_SCI({pad_name}, {term}, {reset}, EDGE_SINGLE, INVERT)"
                elif interrupt_type == 'SMI':
                    # PAD_CFG_GPI_SMI(pad, term, rst, edge, inv)
                    return f"PAD_CFG_GPI_SMI({pad_name}, {term}, {reset}, EDGE_SINGLE, INVERT)"
                else:
                    # PAD_CFG_GPI_TRIG_OWN(pad, term, rst, trig, own)
                    return f"PAD_CFG_GPI_TRIG_OWN({pad_name}, {term}, {reset}, OFF, ACPI)"
            else:
                # Fallback for unknown direction
                return f"PAD_CFG_GPI_TRIG_OWN({pad_name}, {term}, {reset}, OFF, ACPI)"
        
        elif mode in ['NF1', 'NF2', 'NF3', 'NF4', 'NF5', 'NF6', 'NF7']:
            # Native function
            # PAD_CFG_NF(pad, term, rst, func)
            return f"PAD_CFG_NF({pad_name}, {term}, {reset}, {mode})"
        
        else:
            # Unknown mode, use NC (not connected)
            return f"PAD_NC({pad_name}, {term})"
    
    def _generate_vgpio_struct(self, pad: Dict) -> str:
        """
        Generate _PAD_CFG_STRUCT macro for VGPIO pads.
        
        VGPIOs use raw DW0/DW1 format with special flags.
        """
        pad_name = pad['name']
        mode = pad.get('mode', 'GPIO')
        reset = pad.get('reset', 'DEEP')
        direction = pad.get('direction', 'INPUT')
        output_value = pad.get('output_value', 0)
        dw0_raw = pad.get('dw0', '0x00000000')
        
        # Build DW0 flags
        flags = []
        
        # Pad function
        if mode == 'GPIO':
            flags.append('PAD_FUNC(GPIO)')
        elif mode in ['NF1', 'NF2', 'NF3', 'NF4', 'NF5', 'NF6', 'NF7']:
            flags.append(f'PAD_FUNC({mode})')
        else:
            flags.append('PAD_FUNC(GPIO)')
        
        # Reset domain
        flags.append(f'PAD_RESET({reset})')
        
        # Buffer configuration for GPIO mode
        if mode == 'GPIO':
            if direction == 'OUTPUT':
                flags.append('PAD_BUF(RX_DISABLE)')
                if output_value == 1:
                    flags.append('1')  # TX state
            else:
                flags.append('PAD_BUF(TX_DISABLE)')
        
        # Check for NAFVWE bit in raw DW0 (common for VGPIOs)
        if isinstance(dw0_raw, str) and dw0_raw.startswith('0x'):
            dw0_val = int(dw0_raw, 16)
            if dw0_val & (1 << 27):  # NAFVWE bit
                flags.append('PAD_CFG0_NAFVWE_ENABLE')
        
        flags_str = ' | '.join(flags)
        return f"_PAD_CFG_STRUCT({pad_name}, {flags_str}, 0)"
    
    def generate_summary_report(self, pads: List[Dict], output_path: Path):
        """
        Generate a human-readable summary report.
        
        Args:
            pads: List of parsed pad configurations
            output_path: Output file path
        """
        lines = []
        
        lines.append("GPIO Configuration Summary")
        lines.append("=" * 60)
        lines.append(f"Platform: {self.platform}")
        lines.append(f"Total Pads: {len(pads)}")
        lines.append("")
        
        # Count by mode
        mode_counts = {}
        for pad in pads:
            mode = pad.get('mode', 'UNKNOWN')
            mode_counts[mode] = mode_counts.get(mode, 0) + 1
        
        lines.append("Pad Modes:")
        for mode, count in sorted(mode_counts.items()):
            lines.append(f"  {mode}: {count}")
        lines.append("")
        
        # Count by direction (for GPIO mode)
        gpio_pads = [p for p in pads if p.get('mode') == 'GPIO']
        if gpio_pads:
            dir_counts = {}
            for pad in gpio_pads:
                direction = pad.get('direction', 'UNKNOWN')
                dir_counts[direction] = dir_counts.get(direction, 0) + 1
            
            lines.append("GPIO Directions:")
            for direction, count in sorted(dir_counts.items()):
                lines.append(f"  {direction}: {count}")
            lines.append("")
        
        # List all pads with details
        lines.append("Detailed Pad List:")
        lines.append("-" * 60)
        
        current_group = None
        for pad in pads:
            group = pad.get('group', 'UNKNOWN')
            if group != current_group:
                lines.append(f"\n{group}:")
                current_group = group
            
            pad_name = pad['name']
            mode = pad.get('mode', 'UNKNOWN')
            direction = pad.get('direction', 'N/A')
            reset = pad.get('reset', 'N/A')
            term = pad.get('termination', 'N/A')
            
            lines.append(f"  {pad_name:20s} {mode:8s} {direction:8s} "
                        f"reset={reset:8s} term={term}")
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        logger.info(f"Generated summary report at {output_path}")
