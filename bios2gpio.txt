Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

/
├── README.md
├── __pycache__
├── bios2gpio.py
├── create_mock_bios.py
├── gpio_detector.py
├── gpio_generator.py
├── gpio_parser.py
├── implementation_plan.md.resolved
├── platforms
│   ├── __init__.py
│   ├── __pycache__
│   └── alderlake.py
├── requirements.txt
├── task.md.resolved
├── test_gpio.h
├── test_platform.py
├── test_report.txt
└── uefi_extractor.py

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] README.md
# bios2gpio - GPIO Extraction Tool

Extract GPIO configurations from vendor BIOS images without requiring `inteltool` to run on the target hardware.

## Overview

This tool analyzes vendor UEFI BIOS images to extract GPIO pad configurations, which can then be used to create coreboot GPIO configuration files. This eliminates the need to boot vendor firmware on the target hardware and run `inteltool`.

## Supported Platforms

- Intel Alder Lake (12th gen Core, Z690/H670/B660 chipsets)

## Requirements

### System Dependencies

- **ifdtool**: Intel Flash Descriptor tool (included in coreboot `util/ifdtool/`)
- **UEFIExtract** (optional but recommended): UEFI firmware extraction tool
  - Download from: https://github.com/LongSoft/UEFITool

### Python Dependencies

```bash
pip install -r requirements.txt
```

## Installation

1. Build ifdtool:
```bash
cd /path/to/coreboot/util/ifdtool
make
```

2. Install UEFIExtract (optional):
```bash
# Download from https://github.com/LongSoft/UEFITool/releases
# Extract and place UEFIExtract in your PATH
```

3. Install Python dependencies:
```bash
cd /path/to/coreboot/util/bios2gpio
pip install -r requirements.txt
```

## Usage

### Basic Usage

Extract GPIO configuration from a vendor BIOS image:

```bash
./bios2gpio.py --platform alderlake --input vendor_bios.bin --output gpio.h
```

### Advanced Usage

Generate multiple output formats:

```bash
./bios2gpio.py --platform alderlake \
    --input vendor_bios.bin \
    --output gpio.h \
    --json gpio_data.json \
    --report gpio_summary.txt
```

### Options

- `--platform`: Target platform (currently only `alderlake` supported)
- `--input`, `-i`: Input vendor BIOS image file (required)
- `--output`, `-o`: Output coreboot gpio.h file
- `--json`, `-j`: Output JSON file with parsed GPIO data
- `--report`, `-r`: Output human-readable summary report
- `--work-dir`, `-w`: Working directory for extraction (uses temp dir if not specified)
- `--min-entries`: Minimum entries to consider a GPIO table (default: 10)
- `--verbose`, `-v`: Enable verbose logging for debugging

## How It Works

### 1. Firmware Extraction

The tool uses `ifdtool` to extract the BIOS region from Intel Flash Descriptor (IFD) formatted images. If `UEFIExtract` is available, it further extracts individual UEFI modules (PEI/DXE drivers).

### 2. GPIO Table Detection

The tool scans binary data for patterns that match GPIO pad configuration structures:

- **Name-based filtering**: Searches for modules with names containing `Gpio`, `PchInit`, `SiliconInit`, etc.
- **Binary pattern scanning**: Looks for arrays of fixed-size structures (8, 12, or 16 bytes) that match GPIO pad configuration layout
- **Validation**: Verifies that pad configurations have valid values for mode, reset domain, termination, etc.
- **Confidence scoring**: Ranks detected tables by likelihood of being actual GPIO configurations

### 3. Configuration Parsing

Detected tables are parsed into logical GPIO pad configurations:

- Extracts pad mode (GPIO vs native function)
- Determines direction (input/output) for GPIO mode
- Reads output value, pull resistor configuration, reset domain
- Identifies interrupt routing if configured

### 4. Output Generation

Generates coreboot-compatible GPIO configuration files using standard macros:

- `PAD_CFG_GPO()` - GPIO output
- `PAD_CFG_GPI_TRIG_OWN()` - GPIO input
- `PAD_CFG_NF()` - Native function
- `PAD_CFG_GPI_APIC_LOW()` - GPIO input with APIC interrupt
- etc.

## Validation

To validate the tool's accuracy, compare extracted GPIO configurations against a known reference:

```bash
# Extract from MSI Z690 vendor BIOS
./bios2gpio.py --platform alderlake \
    --input msi_z690_vendor.bin \
    --output msi_extracted_gpio.h \
    --json msi_extracted.json

# Compare against coreboot reference
# (Manual comparison or use gpio_comparator.py if implemented)
```

## Limitations

- **Vendor customization**: Heavily customized or obfuscated GPIO initialization code may not be detected
- **Runtime configuration**: Some GPIO pads may be reconfigured at runtime by DXE drivers or ACPI methods
- **Platform support**: Currently only supports Intel Alder Lake; other platforms require additional definitions
- **Accuracy**: Without hardware validation, extracted configurations should be verified before use

## Troubleshooting

### No GPIO tables detected

- Try increasing verbosity: `--verbose`
- Check if the BIOS image is encrypted or compressed
- Ensure the image is a full SPI dump or valid BIOS update file
- Try lowering `--min-entries` threshold

### Incorrect pad names

- The tool uses heuristics to guess pad identities
- Pad names may not match exactly; manual verification recommended
- Compare against Intel PCH datasheet for your platform

### ifdtool not found

- Build ifdtool: `cd util/ifdtool && make`
- Ensure it's in your PATH or the tool will find it in coreboot tree

## Contributing

To add support for additional platforms:

1. Create a new platform definition file in `platforms/`
2. Define GPIO groups, pad structures, and bitfield layouts
3. Update `bios2gpio.py` to recognize the new platform

## License

GPL-2.0-only (same as coreboot)

## References

- Intel Alder Lake PCH Datasheet
- coreboot GPIO documentation
- UEFITool: https://github.com/LongSoft/UEFITool

[File Ends] README.md

[File Begins] bios2gpio.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
bios2gpio - Extract GPIO configuration from vendor BIOS images

This tool extracts GPIO pad configurations from vendor UEFI BIOS images
without requiring inteltool to run on the target hardware.
"""

import sys
import argparse
import logging
from pathlib import Path

# Add current directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

from uefi_extractor import UEFIExtractor
from gpio_detector import GPIOTableDetector
from gpio_parser import GPIOParser
from gpio_generator import GPIOGenerator
from platforms import GPIO_MODULE_PATTERNS

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s: %(message)s'
)
logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(
        description='Extract GPIO configuration from vendor BIOS images',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Extract GPIO from MSI Z690 BIOS
  %(prog)s --platform alderlake --input msi_z690.bin --output gpio.h

  # Extract with JSON output for analysis
  %(prog)s --platform alderlake --input bios.bin --json gpio.json --output gpio.h

  # Verbose mode for debugging
  %(prog)s -v --platform alderlake --input bios.bin --output gpio.h
        """
    )
    
    parser.add_argument(
        '--platform',
        default='alderlake',
        choices=['alderlake'],
        help='Target platform (default: alderlake)'
    )
    
    parser.add_argument(
        '--input', '-i',
        required=True,
        help='Input vendor BIOS image file'
    )
    
    parser.add_argument(
        '--output', '-o',
        help='Output coreboot gpio.h file'
    )
    
    parser.add_argument(
        '--json', '-j',
        help='Output JSON file with parsed GPIO data'
    )
    
    parser.add_argument(
        '--report', '-r',
        help='Output summary report file'
    )
    
    parser.add_argument(
        '--work-dir', '-w',
        help='Working directory for extraction (temp dir if not specified)'
    )
    
    parser.add_argument(
        '--min-entries',
        type=int,
        default=10,
        help='Minimum entries to consider a GPIO table (default: 10)'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose logging'
    )
    
    args = parser.parse_args()
    
    # Set log level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Validate input file
    input_path = Path(args.input)
    if not input_path.exists():
        logger.error(f"Input file not found: {args.input}")
        return 1
    
    logger.info(f"bios2gpio - Extracting GPIO from {input_path}")
    logger.info(f"Platform: {args.platform}")
    
    try:
        # Step 1: Extract UEFI modules
        logger.info("Step 1: Extracting UEFI modules...")
        extractor = UEFIExtractor(str(input_path), args.work_dir)
        
        if not extractor.check_dependencies():
            logger.error("Missing required dependencies")
            return 1
        
        # Extract BIOS region
        bios_region = extractor.get_bios_region()
        logger.info(f"BIOS region: {bios_region}")
        
        # Find GPIO-related modules
        modules = extractor.find_modules(GPIO_MODULE_PATTERNS)
        logger.info(f"Found {len(modules)} GPIO-related modules")
        
        # Also get all binary files for scanning
        all_binaries = extractor.get_all_binary_files()
        logger.info(f"Total binary files to scan: {len(all_binaries)}")
        
        # Step 2: Detect GPIO tables
        logger.info("Step 2: Detecting GPIO tables...")
        detector = GPIOTableDetector(platform=args.platform)
        
        # Scan GPIO-related modules first
        all_tables = []
        files_to_scan = [m['path'] for m in modules] if modules else all_binaries[:50]
        
        for file_path in files_to_scan:
            tables = detector.scan_file(file_path, min_entries=args.min_entries)
            all_tables.extend(tables)
        
        if not all_tables:
            logger.warning("No GPIO tables detected!")
            logger.info("Try scanning the raw BIOS region...")
            tables = detector.scan_file(bios_region, min_entries=args.min_entries)
            all_tables.extend(tables)
        
        if not all_tables:
            logger.error("No GPIO tables found in BIOS image")
            return 1
        
        logger.info(f"Detected {len(all_tables)} potential GPIO tables")
        
        # Filter to best tables
        best_tables = detector.filter_best_tables(all_tables, max_tables=5)
        logger.info(f"Selected {len(best_tables)} highest-confidence tables")
        
        for idx, table in enumerate(best_tables):
            logger.info(f"  Table {idx}: {table['entry_count']} entries, "
                       f"confidence {table['confidence']:.2f}, "
                       f"file: {Path(table['file']).name}")
        
        # Step 3: Parse GPIO tables
        logger.info("Step 3: Parsing GPIO configurations...")
        parser = GPIOParser(platform=args.platform)
        
        parsed_data = parser.parse_multiple_tables(best_tables)
        merged_pads = parser.merge_tables(parsed_data)
        
        logger.info(f"Parsed {len(merged_pads)} GPIO pads")
        
        # Step 4: Generate outputs
        logger.info("Step 4: Generating output files...")
        generator = GPIOGenerator(platform=args.platform)
        
        # Generate JSON if requested
        if args.json:
            json_path = Path(args.json)
            parser.export_json(parsed_data, json_path)
            logger.info(f"JSON output: {json_path}")
        
        # Generate coreboot gpio.h if requested
        if args.output:
            output_path = Path(args.output)
            generator.generate_coreboot_header(merged_pads, output_path)
            logger.info(f"Coreboot gpio.h: {output_path}")
        
        # Generate summary report if requested
        if args.report:
            report_path = Path(args.report)
            generator.generate_summary_report(merged_pads, report_path)
            logger.info(f"Summary report: {report_path}")
        
        # If no output specified, print summary to console
        if not args.output and not args.json and not args.report:
            logger.info("\nSummary:")
            logger.info(f"  Total pads: {len(merged_pads)}")
            
            mode_counts = {}
            for pad in merged_pads:
                mode = pad.get('mode', 'UNKNOWN')
                mode_counts[mode] = mode_counts.get(mode, 0) + 1
            
            logger.info("  Pad modes:")
            for mode, count in sorted(mode_counts.items()):
                logger.info(f"    {mode}: {count}")
            
            logger.info("\nSpecify --output, --json, or --report to save results")
        
        logger.info("\nExtraction complete!")
        return 0
        
    except Exception as e:
        logger.error(f"Error during extraction: {e}", exc_info=args.verbose)
        return 1


if __name__ == '__main__':
    sys.exit(main())

[File Ends] bios2gpio.py

[File Begins] create_mock_bios.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
Create a mock BIOS image with embedded GPIO table for testing.
"""

import struct
import sys
from pathlib import Path

def create_mock_gpio_table():
    """Create a mock GPIO configuration table"""
    entries = []
    
    # Create some realistic-looking GPIO configurations
    # Each entry is 8 bytes: DW0 (4 bytes) + DW1 (4 bytes)
    
    # GPP_B0 - GPIO input, PLTRST, no termination
    dw0 = 0x00000200  # RX enabled, TX disabled, mode=GPIO
    dw1 = 0x80000000  # PLTRST reset
    entries.append(struct.pack('<II', dw0, dw1))
    
    # GPP_B1 - GPIO output = 1, PLTRST
    dw0 = 0x00000101  # TX enabled, RX disabled, output=1, mode=GPIO
    dw1 = 0x80000000  # PLTRST reset
    entries.append(struct.pack('<II', dw0, dw1))
    
    # GPP_B2 - Native function NF1, PLTRST
    dw0 = 0x00000400  # Mode = NF1 (1 << 10)
    dw1 = 0x80000000  # PLTRST reset
    entries.append(struct.pack('<II', dw0, dw1))
    
    # GPP_B3 - GPIO input with pull-up 20K
    dw0 = 0x00000200  # RX enabled, TX disabled
    dw1 = 0x80001800  # PLTRST, termination = UP_20K (6 << 10)
    entries.append(struct.pack('<II', dw0, dw1))
    
    # Add more entries to meet minimum threshold
    for i in range(4, 20):
        # Mix of GPIO and native functions
        if i % 3 == 0:
            # Native function
            dw0 = 0x00000400  # NF1
            dw1 = 0x80000000
        else:
            # GPIO input
            dw0 = 0x00000200
            dw1 = 0x80000000
        entries.append(struct.pack('<II', dw0, dw1))
    
    return b''.join(entries)

def create_mock_bios():
    """Create a mock BIOS image with GPIO table embedded"""
    
    # Create a simple binary blob
    # Header (256 bytes of padding)
    header = b'\x00' * 256
    
    # GPIO table
    gpio_table = create_mock_gpio_table()
    
    # More padding
    padding = b'\xFF' * 1024
    
    # Combine
    mock_bios = header + gpio_table + padding
    
    return mock_bios

def main():
    output_file = Path(__file__).parent / 'test_mock_bios.bin'
    
    print("Creating mock BIOS image for testing...")
    mock_bios = create_mock_bios()
    
    with open(output_file, 'wb') as f:
        f.write(mock_bios)
    
    print(f"Created: {output_file}")
    print(f"Size: {len(mock_bios)} bytes")
    print("\nYou can test with:")
    print(f"  python3 bios2gpio.py --input {output_file.name} --output test_gpio.h --verbose")
    
    return 0

if __name__ == '__main__':
    sys.exit(main())

[File Ends] create_mock_bios.py

[File Begins] gpio_detector.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
GPIO table detection module.

Implements heuristics to locate GPIO configuration tables within
UEFI modules and binary data.
"""

import struct
import logging
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from platforms.alderlake import GPIO_GROUPS, AlderLakeGpioPadConfig

logger = logging.getLogger(__name__)


class GPIOTableDetector:
    """Detects GPIO configuration tables in binary data"""
    
    def __init__(self, platform='alderlake'):
        """
        Initialize GPIO table detector.
        
        Args:
            platform: Platform name (currently only 'alderlake' supported)
        """
        self.platform = platform
        
        # Platform-specific configuration
        if platform == 'alderlake':
            self.gpio_groups = GPIO_GROUPS
            self.pad_config_class = AlderLakeGpioPadConfig
            # Typical pad config sizes: 8 bytes (DW0+DW1), 12, 16 bytes
            self.expected_entry_sizes = [8, 12, 16]
        else:
            raise ValueError(f"Unsupported platform: {platform}")
    
    def scan_for_tables(self, data: bytes, min_entries: int = 10) -> List[Dict]:
        """
        Scan binary data for potential GPIO configuration tables.
        
        Args:
            data: Binary data to scan
            min_entries: Minimum number of entries to consider it a table
        
        Returns:
            List of detected tables with metadata
        """
        tables = []
        
        for entry_size in self.expected_entry_sizes:
            logger.debug(f"Scanning for tables with entry size {entry_size}")
            detected = self._scan_fixed_size_entries(data, entry_size, min_entries)
            tables.extend(detected)
        
        logger.info(f"Detected {len(tables)} potential GPIO tables")
        return tables
    
    def _scan_fixed_size_entries(self, data: bytes, entry_size: int, 
                                  min_entries: int) -> List[Dict]:
        """
        Scan for arrays of fixed-size entries that look like GPIO configs.
        
        Args:
            data: Binary data
            entry_size: Size of each entry in bytes
            min_entries: Minimum entries to consider
        
        Returns:
            List of detected tables
        """
        tables = []
        data_len = len(data)
        
        # Scan through data looking for sequences of valid-looking entries
        offset = 0
        while offset < data_len - (entry_size * min_entries):
            # Try to parse entries starting at this offset
            valid_count = 0
            current_offset = offset
            entries = []
            
            while current_offset + entry_size <= data_len:
                try:
                    # Try to parse as GPIO pad config
                    if entry_size >= 8:
                        entry_data = data[current_offset:current_offset + entry_size]
                        pad_config = self.pad_config_class(entry_data)
                        
                        # Validate this looks like a real GPIO config
                        if self._is_valid_pad_config(pad_config):
                            valid_count += 1
                            entries.append({
                                'offset': current_offset,
                                'config': pad_config,
                            })
                            current_offset += entry_size
                        else:
                            # Invalid entry, stop this sequence
                            break
                    else:
                        break
                        
                except Exception as e:
                    # Parsing failed, stop this sequence
                    break
            
            # If we found enough valid entries, record this as a table
            if valid_count >= min_entries:
                table_info = {
                    'offset': offset,
                    'entry_size': entry_size,
                    'entry_count': valid_count,
                    'total_size': valid_count * entry_size,
                    'entries': entries,
                    'confidence': self._calculate_confidence(entries),
                }
                tables.append(table_info)
                logger.debug(f"Found potential table at offset 0x{offset:x}: "
                           f"{valid_count} entries, confidence {table_info['confidence']:.2f}")
                
                # Skip past this table
                offset = current_offset
            else:
                # Move to next potential alignment
                offset += 4  # Try 4-byte alignment
        
        return tables
    
    def _is_valid_pad_config(self, config: AlderLakeGpioPadConfig) -> bool:
        """
        Check if a parsed pad config looks valid.
        
        Args:
            config: Parsed pad configuration
        
        Returns:
            True if config appears valid
        """
        # Check DW0 and DW1 aren't all zeros or all ones
        if config.dw0 == 0 and config.dw1 == 0:
            return False
        if config.dw0 == 0xFFFFFFFF or config.dw1 == 0xFFFFFFFF:
            return False
        
        # Check pad mode is in valid range (0-7)
        try:
            mode = config.get_pad_mode()
            if mode.value > 7:
                return False
        except:
            return False
        
        # Check reset config is valid (0-2)
        try:
            reset = config.get_reset_config()
            if reset.value > 2:
                return False
        except:
            return False
        
        # Check termination is in reasonable range
        try:
            term = config.get_termination()
            if term.value > 15:  # Max value for 4-bit field
                return False
        except:
            return False
        
        return True
    
    def _calculate_confidence(self, entries: List[Dict]) -> float:
        """
        Calculate confidence score for a detected table.
        
        Args:
            entries: List of parsed entries
        
        Returns:
            Confidence score (0.0 to 1.0)
        """
        if not entries:
            return 0.0
        
        score = 0.0
        
        # More entries = higher confidence
        entry_count_score = min(len(entries) / 100.0, 0.3)
        score += entry_count_score
        
        # Check for variety in configurations (not all the same)
        unique_dw0 = len(set(e['config'].dw0 for e in entries))
        variety_score = min(unique_dw0 / len(entries), 0.2)
        score += variety_score
        
        # Check for reasonable distribution of pad modes
        gpio_count = sum(1 for e in entries if e['config'].get_pad_mode().value == 0)
        native_count = len(entries) - gpio_count
        if gpio_count > 0 and native_count > 0:
            score += 0.2  # Mix of GPIO and native functions is typical
        
        # Check for sequential or grouped patterns (typical in real tables)
        # This is a simplified check - real implementation could be more sophisticated
        score += 0.3  # Base score for passing basic validation
        
        return min(score, 1.0)
    
    def filter_best_tables(self, tables: List[Dict], max_tables: int = 3) -> List[Dict]:
        """
        Filter to the most likely GPIO tables based on confidence.
        
        Args:
            tables: List of detected tables
            max_tables: Maximum number of tables to return
        
        Returns:
            Filtered list of most likely tables
        """
        # Sort by confidence descending
        sorted_tables = sorted(tables, key=lambda t: t['confidence'], reverse=True)
        
        # Return top N
        return sorted_tables[:max_tables]
    
    def scan_file(self, file_path: Path, min_entries: int = 10) -> List[Dict]:
        """
        Scan a binary file for GPIO tables.
        
        Args:
            file_path: Path to binary file
            min_entries: Minimum entries to consider a table
        
        Returns:
            List of detected tables
        """
        logger.info(f"Scanning file: {file_path}")
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            tables = self.scan_for_tables(data, min_entries)
            
            # Add file info to each table
            for table in tables:
                table['file'] = str(file_path)
                table['file_size'] = len(data)
            
            return tables
            
        except Exception as e:
            logger.error(f"Error scanning {file_path}: {e}")
            return []
    
    def scan_multiple_files(self, file_paths: List[Path], 
                           min_entries: int = 10) -> Dict[str, List[Dict]]:
        """
        Scan multiple files for GPIO tables.
        
        Args:
            file_paths: List of file paths to scan
            min_entries: Minimum entries per table
        
        Returns:
            Dict mapping file paths to detected tables
        """
        results = {}
        
        for file_path in file_paths:
            tables = self.scan_file(file_path, min_entries)
            if tables:
                results[str(file_path)] = tables
        
        return results

[File Ends] gpio_detector.py

[File Begins] gpio_generator.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
GPIO generator module.

Generates coreboot-compatible GPIO configuration files from parsed data.
"""

import logging
from pathlib import Path
from typing import List, Dict
from platforms.alderlake import PadMode

logger = logging.getLogger(__name__)


class GPIOGenerator:
    """Generates coreboot GPIO configuration files"""
    
    def __init__(self, platform='alderlake'):
        """
        Initialize GPIO generator.
        
        Args:
            platform: Platform name
        """
        self.platform = platform
    
    def generate_coreboot_header(self, pads: List[Dict], output_path: Path):
        """
        Generate coreboot-style gpio.h file.
        
        Args:
            pads: List of parsed pad configurations
            output_path: Output file path
        """
        lines = []
        
        # Header
        lines.append("/* SPDX-License-Identifier: GPL-2.0-only */")
        lines.append("")
        lines.append("/* Generated by bios2gpio tool */")
        lines.append("")
        lines.append("#include <soc/gpio.h>")
        lines.append("")
        lines.append("static const struct pad_config gpio_table[] = {")
        
        # Group pads by GPIO group for better organization
        current_group = None
        
        for pad in pads:
            pad_name = pad['name']
            group = pad.get('group', 'UNKNOWN')
            
            # Add group header comment
            if group != current_group:
                if current_group is not None:
                    lines.append("")
                lines.append(f"\t/* ------- GPIO Group {group} ------- */")
                lines.append("")
                current_group = group
            
            # Generate macro for this pad
            macro = self._generate_pad_macro(pad)
            if macro:
                # Add comment with pad name and function
                mode = pad.get('mode', 'GPIO')
                comment = f"\t/* {pad_name} - {mode} */"
                lines.append(comment)
                lines.append(f"\t{macro},")
        
        # Footer
        lines.append("};")
        lines.append("")
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        logger.info(f"Generated coreboot gpio.h at {output_path}")
    
    def _generate_pad_macro(self, pad: Dict) -> str:
        """
        Generate coreboot PAD_CFG_* macro for a single pad.
        
        Args:
            pad: Pad configuration dict
        
        Returns:
            Macro string
        """
        pad_name = pad['name']
        mode = pad.get('mode', 'GPIO')
        direction = pad.get('direction', 'INPUT')
        output_value = pad.get('output_value', 0)
        reset = pad.get('reset', 'PLTRST')
        termination = pad.get('termination', 'NONE')
        interrupt_type = pad.get('interrupt', 'NONE')
        
        # Map termination names to coreboot constants
        term_map = {
            'NONE': 'NONE',
            'DN_5K': 'DN_5K',
            'DN_20K': 'DN_20K',
            'UP_1K': 'UP_1K',
            'UP_2K': 'UP_2K',
            'UP_5K': 'UP_5K',
            'UP_20K': 'UP_20K',
            'UP_1K_2K': 'UP_1K_2K',
            'NATIVE': 'NATIVE',
        }
        term = term_map.get(termination, 'NONE')
        
        # Generate appropriate macro based on configuration
        if mode == 'GPIO':
            if direction == 'OUTPUT':
                # PAD_CFG_GPO(pad, val, rst)
                return f"PAD_CFG_GPO({pad_name}, {output_value}, {reset})"
            elif direction == 'INPUT':
                if interrupt_type == 'APIC':
                    # PAD_CFG_GPI_APIC(pad, term, rst)
                    return f"PAD_CFG_GPI_APIC_LOW({pad_name}, {term}, {reset})"
                elif interrupt_type == 'SCI':
                    # PAD_CFG_GPI_SCI(pad, term, rst, edge, inv)
                    return f"PAD_CFG_GPI_SCI({pad_name}, {term}, {reset}, EDGE_SINGLE, INVERT)"
                elif interrupt_type == 'SMI':
                    # PAD_CFG_GPI_SMI(pad, term, rst, edge, inv)
                    return f"PAD_CFG_GPI_SMI({pad_name}, {term}, {reset}, EDGE_SINGLE, INVERT)"
                else:
                    # PAD_CFG_GPI_TRIG_OWN(pad, term, rst, trig, own)
                    return f"PAD_CFG_GPI_TRIG_OWN({pad_name}, {term}, {reset}, OFF, ACPI)"
            else:
                # Fallback for unknown direction
                return f"PAD_CFG_GPI_TRIG_OWN({pad_name}, {term}, {reset}, OFF, ACPI)"
        
        elif mode in ['NF1', 'NF2', 'NF3', 'NF4', 'NF5', 'NF6', 'NF7']:
            # Native function
            # PAD_CFG_NF(pad, term, rst, func)
            return f"PAD_CFG_NF({pad_name}, {term}, {reset}, {mode})"
        
        else:
            # Unknown mode, use NC (not connected)
            return f"PAD_NC({pad_name}, {term})"
    
    def generate_summary_report(self, pads: List[Dict], output_path: Path):
        """
        Generate a human-readable summary report.
        
        Args:
            pads: List of parsed pad configurations
            output_path: Output file path
        """
        lines = []
        
        lines.append("GPIO Configuration Summary")
        lines.append("=" * 60)
        lines.append(f"Platform: {self.platform}")
        lines.append(f"Total Pads: {len(pads)}")
        lines.append("")
        
        # Count by mode
        mode_counts = {}
        for pad in pads:
            mode = pad.get('mode', 'UNKNOWN')
            mode_counts[mode] = mode_counts.get(mode, 0) + 1
        
        lines.append("Pad Modes:")
        for mode, count in sorted(mode_counts.items()):
            lines.append(f"  {mode}: {count}")
        lines.append("")
        
        # Count by direction (for GPIO mode)
        gpio_pads = [p for p in pads if p.get('mode') == 'GPIO']
        if gpio_pads:
            dir_counts = {}
            for pad in gpio_pads:
                direction = pad.get('direction', 'UNKNOWN')
                dir_counts[direction] = dir_counts.get(direction, 0) + 1
            
            lines.append("GPIO Directions:")
            for direction, count in sorted(dir_counts.items()):
                lines.append(f"  {direction}: {count}")
            lines.append("")
        
        # List all pads with details
        lines.append("Detailed Pad List:")
        lines.append("-" * 60)
        
        current_group = None
        for pad in pads:
            group = pad.get('group', 'UNKNOWN')
            if group != current_group:
                lines.append(f"\n{group}:")
                current_group = group
            
            pad_name = pad['name']
            mode = pad.get('mode', 'UNKNOWN')
            direction = pad.get('direction', 'N/A')
            reset = pad.get('reset', 'N/A')
            term = pad.get('termination', 'N/A')
            
            lines.append(f"  {pad_name:20s} {mode:8s} {direction:8s} "
                        f"reset={reset:8s} term={term}")
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        logger.info(f"Generated summary report at {output_path}")

[File Ends] gpio_generator.py

[File Begins] gpio_parser.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
GPIO parser module.

Parses detected GPIO tables and converts to structured data.
"""

import json
import logging
from pathlib import Path
from typing import List, Dict, Optional
from platforms.alderlake import (
    AlderLakeGpioPadConfig,
    GPIO_GROUPS,
    get_pad_name,
    find_group_for_pad,
    PadMode,
)

logger = logging.getLogger(__name__)


class GPIOParser:
    """Parses GPIO configuration tables into structured data"""
    
    def __init__(self, platform='alderlake'):
        """
        Initialize GPIO parser.
        
        Args:
            platform: Platform name
        """
        self.platform = platform
        
        if platform == 'alderlake':
            self.gpio_groups = GPIO_GROUPS
            self.pad_config_class = AlderLakeGpioPadConfig
        else:
            raise ValueError(f"Unsupported platform: {platform}")
    
    def parse_table(self, table: Dict, community: int = 0) -> List[Dict]:
        """
        Parse a detected GPIO table into structured pad configurations.
        
        Args:
            table: Table dict from detector
            community: GPIO community number (for pad name resolution)
        
        Returns:
            List of parsed pad configurations
        """
        parsed_pads = []
        
        for idx, entry in enumerate(table['entries']):
            config = entry['config']
            
            # Try to determine pad name
            # This is challenging without knowing the exact mapping used by vendor
            # We'll use index-based naming as fallback
            group_name, local_idx = self._guess_pad_identity(idx, community, config)
            
            if group_name:
                pad_name = get_pad_name(group_name, local_idx)
            else:
                pad_name = f'UNKNOWN_{idx}'
            
            pad_info = {
                'index': idx,
                'name': pad_name,
                'group': group_name,
                'local_index': local_idx,
                'offset': entry['offset'],
                **config.to_dict()
            }
            
            parsed_pads.append(pad_info)
        
        logger.info(f"Parsed {len(parsed_pads)} pads from table")
        return parsed_pads
    
    def _guess_pad_identity(self, index: int, community: int, 
                           config: AlderLakeGpioPadConfig) -> tuple:
        """
        Attempt to guess pad identity from index and configuration.
        
        This is heuristic-based and may not be 100% accurate.
        
        Args:
            index: Index in table
            community: Community number
            config: Pad configuration
        
        Returns:
            Tuple of (group_name, local_index) or (None, None)
        """
        # Try to find group based on community and index
        result = find_group_for_pad(index, community)
        if result:
            return result
        
        # Fallback: return None to indicate unknown
        return (None, None)
    
    def parse_multiple_tables(self, tables: List[Dict], 
                             community_hints: Optional[List[int]] = None) -> Dict:
        """
        Parse multiple GPIO tables.
        
        Args:
            tables: List of detected tables
            community_hints: Optional list of community numbers for each table
        
        Returns:
            Dict with parsed data organized by table
        """
        results = {
            'platform': self.platform,
            'tables': []
        }
        
        for idx, table in enumerate(tables):
            community = community_hints[idx] if community_hints else 0
            
            parsed_pads = self.parse_table(table, community)
            
            table_result = {
                'table_index': idx,
                'offset': table['offset'],
                'entry_count': table['entry_count'],
                'confidence': table['confidence'],
                'file': table.get('file', 'unknown'),
                'pads': parsed_pads,
            }
            
            results['tables'].append(table_result)
        
        return results
    
    def export_json(self, parsed_data: Dict, output_path: Path):
        """
        Export parsed data to JSON file.
        
        Args:
            parsed_data: Parsed GPIO data
            output_path: Output file path
        """
        with open(output_path, 'w') as f:
            json.dump(parsed_data, f, indent=2)
        
        logger.info(f"Exported GPIO data to {output_path}")
    
    def merge_tables(self, parsed_data: Dict) -> List[Dict]:
        """
        Merge multiple tables into a single pad list.
        
        Handles deduplication and conflict resolution.
        
        Args:
            parsed_data: Parsed data with multiple tables
        
        Returns:
            Merged list of pads
        """
        merged_pads = {}
        
        for table in parsed_data['tables']:
            for pad in table['pads']:
                pad_name = pad['name']
                
                # If we already have this pad, keep the one from higher confidence table
                if pad_name in merged_pads:
                    existing_confidence = merged_pads[pad_name].get('table_confidence', 0)
                    new_confidence = table['confidence']
                    
                    if new_confidence > existing_confidence:
                        merged_pads[pad_name] = pad
                        merged_pads[pad_name]['table_confidence'] = new_confidence
                else:
                    merged_pads[pad_name] = pad
                    merged_pads[pad_name]['table_confidence'] = table['confidence']
        
        # Convert back to list, sorted by name
        merged_list = sorted(merged_pads.values(), key=lambda p: p['name'])
        
        logger.info(f"Merged to {len(merged_list)} unique pads")
        return merged_list

[File Ends] gpio_parser.py

[File Begins] implementation_plan.md.resolved
# GPIO Extraction Tool for Intel Z690/Alder Lake Platforms

## Goal

Develop a static GPIO extraction tool that can extract GPIO configurations directly from vendor BIOS images without requiring `inteltool` to run on the specific hardware. The tool will be validated using the MSI PRO Z690-A (ms7d25) as a reference platform (already supported in coreboot), then applied to extract GPIO configuration for the ASRock Z690 Steel Legend.

## Background

Currently, GPIO configuration for Intel boards is obtained by:
1. Booting vendor firmware on the target hardware
2. Running `inteltool` to dump live GPIO registers
3. Using `intelp2m` to convert register dumps to coreboot macros

This approach requires physical access to each specific board model. The proposed method extracts GPIO tables directly from the vendor BIOS image by:
- Parsing UEFI firmware modules
- Locating GPIO configuration data structures
- Decoding pad configuration tables
- Generating coreboot-compatible GPIO headers

## User Review Required

> [!IMPORTANT]
> **Verification Strategy**
> This tool's accuracy will be validated by comparing extracted GPIO configurations from MSI Z690 vendor BIOS against the existing coreboot [gpio.h](file:///run/media/julian/ML2/Python/coreboot/coreboot/src/mainboard/msi/ms7d25/gpio.h) for that board. A match rate of 90-95% will be considered successful validation.

> [!WARNING]
> **Limitations**
> - Vendors that heavily customize or obfuscate GPIO initialization code may not be compatible
> - Some GPIO pads may be reconfigured at runtime by DXE drivers or ACPI methods
> - The tool targets Intel FSP-based platforms; non-FSP platforms may require different approaches

## Proposed Changes

### Core Extraction Pipeline

#### [NEW] [bios2gpio.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/bios2gpio.py)

Main orchestration script that coordinates the entire extraction pipeline:
- Accepts vendor BIOS image as input
- Invokes firmware extraction, GPIO table detection, parsing, and output generation
- Provides CLI interface with options for platform selection, output formats, etc.

---

### Firmware Extraction Module

#### [NEW] [uefi_extractor.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/uefi_extractor.py)

Handles UEFI firmware image parsing and module extraction:
- Uses `ifdtool` to split IFD regions (Descriptor, ME, BIOS, etc.)
- Invokes `UEFIExtract` to extract PEI/DXE modules from BIOS region
- Organizes extracted modules into a structured directory tree
- Provides module classification based on names and GUIDs

---

### GPIO Table Detection Module

#### [NEW] [gpio_detector.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/gpio_detector.py)

Implements heuristics to locate GPIO configuration tables within UEFI modules:
- **Name-based filtering**: Searches for modules with names containing `Gpio`, `PchInit`, `SiliconInit`, etc.
- **Binary pattern scanning**: Looks for repeated fixed-size structures matching GPIO pad configuration layout
- **Signature validation**: Verifies pad numbers are within valid ranges for the target SoC
- Returns candidate tables with confidence scores

---

### Platform-Specific Definitions

#### [NEW] [platforms/alderlake.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/platforms/alderlake.py)

Defines Alder Lake / Z690-specific GPIO structures and metadata:
- GPIO pad configuration struct layout (DW0, DW1, DW2, DW3 register definitions)
- GPIO group definitions (GPP_A, GPP_B, GPP_C, etc.) with pad ranges
- Bitfield definitions for mode, direction, pull-up/down, reset domain, interrupt config
- Known UEFI module GUIDs for Alder Lake FSP

```python
# Example structure definition
class AlderLakeGpioPadConfig:
    """
    Represents a single GPIO pad configuration entry.
    Typically 16 bytes: pad_id (2), flags (2), dw0 (4), dw1 (4), dw2 (4)
    """
    def __init__(self, raw_bytes):
        self.pad_id = struct.unpack('<H', raw_bytes[0:2])[0]
        self.flags = struct.unpack('<H', raw_bytes[2:4])[0]
        self.dw0 = struct.unpack('<I', raw_bytes[4:8])[0]
        self.dw1 = struct.unpack('<I', raw_bytes[8:12])[0]
        # DW2/DW3 may not always be present in vendor tables
```

---

### GPIO Parser Module

#### [NEW] [gpio_parser.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/gpio_parser.py)

Decodes binary GPIO tables into logical pad configurations:
- Reads raw binary data from detected tables
- Interprets each entry using platform-specific struct definitions
- Extracts logical properties from register bitfields:
  - Pad mode (GPIO vs native function)
  - Direction (input/output)
  - Output value (high/low)
  - Pull resistor configuration
  - Reset domain (RSMRST, PLTRST, DEEP)
  - Interrupt configuration
- Outputs structured data (JSON, Python dict, etc.)

---

### Output Generation Module

#### [NEW] [gpio_generator.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/gpio_generator.py)

Generates coreboot-compatible GPIO configuration files:
- Converts parsed GPIO data to coreboot macro invocations
- Supports macros like `PAD_CFG_GPO`, `PAD_CFG_GPI_TRIG_OWN`, `PAD_CFG_NF`, etc.
- Formats output to match coreboot style (groups, comments, alignment)
- Generates both [gpio.h](file:///run/media/julian/ML2/Python/coreboot/coreboot/src/mainboard/msi/ms7d25/gpio.h) format and intermediate JSON for analysis

Example output:
```c
/* GPP_B0 - GPIO */
PAD_CFG_GPI_TRIG_OWN(GPP_B0, NONE, PLTRST, OFF, ACPI),
/* GPP_B12 - SLP_S0# */
PAD_CFG_NF(GPP_B12, NONE, PLTRST, NF1),
```

---

### Verification and Comparison Module

#### [NEW] [gpio_comparator.py](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/gpio_comparator.py)

Compares extracted GPIO configurations against reference data:
- Parses existing coreboot [gpio.h](file:///run/media/julian/ML2/Python/coreboot/coreboot/src/mainboard/msi/ms7d25/gpio.h) files into normalized format
- Compares extracted vs reference configurations pad-by-pad
- Calculates match statistics:
  - Exact matches
  - Partial matches (same pad, different properties)
  - Missing pads
  - Extra pads
- Generates detailed diff reports highlighting discrepancies

---

### Supporting Files

#### [NEW] [requirements.txt](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/requirements.txt)

Python dependencies:
```
pyelftools>=0.29
```

#### [NEW] [README.md](file:///run/media/julian/ML2/Python/coreboot/coreboot/util/bios2gpio/README.md)

Documentation covering:
- Tool overview and use cases
- Installation instructions
- Usage examples
- Platform support matrix
- Troubleshooting guide
- Technical details on GPIO table detection

## Verification Plan

### Phase 1: MSI Z690 Validation

1. **Obtain MSI PRO Z690-A vendor BIOS**
   - Download latest BIOS update from MSI website
   - Extract raw BIOS region

2. **Extract GPIO configuration**
   ```bash
   ./bios2gpio.py --platform alderlake \
                  --input msi_z690_vendor.bin \
                  --output msi_extracted_gpio.h \
                  --json msi_extracted_gpio.json
   ```

3. **Compare against coreboot reference**
   ```bash
   ./gpio_comparator.py \
       --extracted msi_extracted_gpio.json \
       --reference src/mainboard/msi/ms7d25/gpio.h \
       --platform alderlake \
       --report msi_comparison_report.txt
   ```

4. **Success criteria**
   - ≥90% exact pad matches
   - Remaining differences in non-critical fields or intentional coreboot modifications
   - No missing critical pads (SPI, power control, reset, etc.)

### Phase 2: ASRock Z690 Application

1. **Obtain ASRock Z690 Steel Legend vendor BIOS**
   - Download from ASRock support site

2. **Extract GPIO configuration**
   ```bash
   ./bios2gpio.py --platform alderlake \
                  --input asrock_z690_steel_legend.bin \
                  --output asrock_z690_gpio.h \
                  --json asrock_z690_gpio.json
   ```

3. **Sanity checks**
   - Verify all pad IDs are valid for Z690
   - Check critical pads have reasonable configurations
   - Compare against MSI Z690 for common platform elements (ESPI, SMBus, etc.)

4. **Integration**
   - Copy generated [gpio.h](file:///run/media/julian/ML2/Python/coreboot/coreboot/src/mainboard/msi/ms7d25/gpio.h) to [src/mainboard/asrock/z690_steel_legend/gpio.h](file:///run/media/julian/ML2/Python/coreboot/coreboot/src/mainboard/asrock/z690_steel_legend/gpio.h)
   - Build coreboot with new GPIO configuration
   - (Future) Test on actual hardware

### Automated Tests

Create unit tests for:
- UEFI module extraction
- GPIO table pattern detection
- Pad configuration struct parsing
- Macro generation
- Comparison logic

## Technical Notes

### GPIO Pad Configuration Structure

For Alder Lake, GPIO pad configuration is typically stored as:
- **DW0 (DWORD 0)**: Pad mode, reset config, RX/TX state, output value
- **DW1 (DWORD 1)**: Interrupt config, termination, pad ownership
- **DW2/DW3**: Additional platform-specific settings

The exact layout matches the hardware PADCFG registers documented in Intel's PCH datasheets.

### Detection Strategy

GPIO tables are identified by:
1. **Structural patterns**: Arrays of fixed-size entries (typically 12-16 bytes)
2. **Value validation**: Pad IDs within known ranges for the platform
3. **Context clues**: Located in modules with GPIO-related names or near MMIO write loops

### Fallback Strategies

If automated detection fails:
- Manual inspection using Ghidra/IDA to locate GPIO init code
- Search for known GPIO MMIO base addresses (P2SB + community offsets)
- Analyze ACPI tables for GpioIo/GpioInt resources as hints

[File Ends] implementation_plan.md.resolved

[File Begins] platforms/__init__.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""Platform package initialization"""

from .alderlake import (
    AlderLakeGpioPadConfig,
    GPIO_GROUPS,
    PadMode,
    PadDirection,
    PadPull,
    PadReset,
    get_pad_name,
    find_group_for_pad,
    GPIO_MODULE_PATTERNS,
)

__all__ = [
    'AlderLakeGpioPadConfig',
    'GPIO_GROUPS',
    'PadMode',
    'PadDirection',
    'PadPull',
    'PadReset',
    'get_pad_name',
    'find_group_for_pad',
    'GPIO_MODULE_PATTERNS',
]

[File Ends] platforms/__init__.py

[File Begins] platforms/alderlake.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
Alder Lake / Z690 GPIO platform definitions.

This module defines the GPIO pad configuration structures and metadata
specific to Intel Alder Lake platforms (12th gen Core, Z690/H670/B660 chipsets).
"""

import struct
from typing import Dict, List, Tuple, Optional
from enum import IntEnum


class PadMode(IntEnum):
    """GPIO pad mode selection"""
    GPIO = 0
    NF1 = 1  # Native Function 1
    NF2 = 2
    NF3 = 3
    NF4 = 4
    NF5 = 5
    NF6 = 6
    NF7 = 7


class PadDirection(IntEnum):
    """GPIO direction for GPIO mode"""
    INPUT = 0
    OUTPUT = 1


class PadPull(IntEnum):
    """Termination/Pull resistor configuration"""
    NONE = 0
    DN_5K = 1   # Pull-down 5K
    DN_20K = 2  # Pull-down 20K
    UP_1K = 3   # Pull-up 1K
    UP_2K = 4   # Pull-up 2K
    UP_5K = 5   # Pull-up 5K
    UP_20K = 6  # Pull-up 20K
    UP_1K_2K = 7  # Pull-up 1K + 2K
    NATIVE = 8


class PadReset(IntEnum):
    """Reset domain configuration"""
    PWROK = 0    # RSMRST
    DEEP = 1     # Deep sleep reset
    PLTRST = 2   # Platform reset
    RSMRST = 0   # Alias for PWROK


class PadTrigger(IntEnum):
    """Interrupt trigger type"""
    OFF = 0
    EDGE_SINGLE = 1
    EDGE_BOTH = 2
    LEVEL = 3


class PadOwner(IntEnum):
    """Pad ownership"""
    ACPI = 0
    GPIO_DRIVER = 1


# GPIO Community and Group definitions for Alder Lake PCH-P/M/S
# Based on Intel Alder Lake PCH datasheet

GPIO_GROUPS = {
    # Community 0
    'GPP_I': {'community': 0, 'group': 0, 'pad_start': 0, 'pad_count': 23},
    'GPP_R': {'community': 0, 'group': 1, 'pad_start': 23, 'pad_count': 22},
    'GPP_J': {'community': 0, 'group': 2, 'pad_start': 45, 'pad_count': 12},
    'VGPIO': {'community': 0, 'group': 3, 'pad_start': 57, 'pad_count': 38},
    'VGPIO_0': {'community': 0, 'group': 4, 'pad_start': 95, 'pad_count': 12},
    
    # Community 1
    'GPP_B': {'community': 1, 'group': 0, 'pad_start': 0, 'pad_count': 24},
    'GPP_G': {'community': 1, 'group': 1, 'pad_start': 24, 'pad_count': 8},
    'GPP_H': {'community': 1, 'group': 2, 'pad_start': 32, 'pad_count': 24},
    
    # Community 2
    'GPD': {'community': 2, 'group': 0, 'pad_start': 0, 'pad_count': 13},
    
    # Community 3
    'GPP_A': {'community': 3, 'group': 0, 'pad_start': 0, 'pad_count': 15},
    'GPP_C': {'community': 3, 'group': 1, 'pad_start': 15, 'pad_count': 24},
    'VGPIO_PCIE': {'community': 3, 'group': 2, 'pad_start': 39, 'pad_count': 80},
    
    # Community 4
    'GPP_S': {'community': 4, 'group': 0, 'pad_start': 0, 'pad_count': 8},
    'GPP_E': {'community': 4, 'group': 1, 'pad_start': 8, 'pad_count': 22},
    'GPP_K': {'community': 4, 'group': 2, 'pad_start': 30, 'pad_count': 12},
    'GPP_F': {'community': 4, 'group': 3, 'pad_start': 42, 'pad_count': 24},
    
    # Community 5
    'GPP_D': {'community': 5, 'group': 0, 'pad_start': 0, 'pad_count': 24},
}


class AlderLakeGpioPadConfig:
    """
    Represents a single GPIO pad configuration entry as found in vendor BIOS.
    
    The structure typically matches the hardware PADCFG registers:
    - DW0: Pad mode, reset config, RX/TX state, output value
    - DW1: Interrupt config, termination, ownership
    - DW2/DW3: Additional settings (may not always be present)
    """
    
    # DW0 bit definitions (based on Intel PCH datasheet)
    DW0_RXPADSTSEL_MASK = 0x3 << 29
    DW0_RXRAW1_MASK = 0x1 << 28
    DW0_RXEVCFG_MASK = 0x3 << 25
    DW0_PREGFRXSEL_MASK = 0x1 << 24
    DW0_RXINV_MASK = 0x1 << 23
    DW0_GPIROUTIOXAPIC_MASK = 0x1 << 20
    DW0_GPIROUTSCI_MASK = 0x1 << 19
    DW0_GPIROUTSMI_MASK = 0x1 << 18
    DW0_GPIROUTNMI_MASK = 0x1 << 17
    DW0_PMODE_MASK = 0xF << 10
    DW0_GPIORXDIS_MASK = 0x1 << 9
    DW0_GPIOTXDIS_MASK = 0x1 << 8
    DW0_GPIORXSTATE_MASK = 0x1 << 1
    DW0_GPIOTXSTATE_MASK = 0x1 << 0
    
    # DW1 bit definitions
    DW1_PADRSTCFG_MASK = 0x3 << 30
    DW1_INTSEL_MASK = 0xFF << 0
    DW1_TERM_MASK = 0xF << 10
    
    def __init__(self, raw_bytes: bytes, offset: int = 0):
        """
        Parse a GPIO pad configuration from raw bytes.
        
        Args:
            raw_bytes: Raw binary data containing the pad config
            offset: Offset into raw_bytes where this pad config starts
        """
        if len(raw_bytes) < offset + 8:
            raise ValueError("Insufficient data for GPIO pad config")
        
        # Most vendor BIOS tables store at minimum DW0 and DW1
        self.dw0 = struct.unpack('<I', raw_bytes[offset:offset+4])[0]
        self.dw1 = struct.unpack('<I', raw_bytes[offset+4:offset+8])[0]
        
        # DW2/DW3 may be present in some implementations
        self.dw2 = 0
        self.dw3 = 0
        if len(raw_bytes) >= offset + 16:
            self.dw2 = struct.unpack('<I', raw_bytes[offset+8:offset+12])[0]
            self.dw3 = struct.unpack('<I', raw_bytes[offset+12:offset+16])[0]
    
    def get_pad_mode(self) -> PadMode:
        """Extract pad mode from DW0"""
        mode_val = (self.dw0 & self.DW0_PMODE_MASK) >> 10
        try:
            return PadMode(mode_val)
        except ValueError:
            return PadMode.GPIO
    
    def get_direction(self) -> PadDirection:
        """Get GPIO direction (only meaningful in GPIO mode)"""
        tx_disabled = (self.dw0 & self.DW0_GPIOTXDIS_MASK) != 0
        rx_disabled = (self.dw0 & self.DW0_GPIORXDIS_MASK) != 0
        
        if not tx_disabled and rx_disabled:
            return PadDirection.OUTPUT
        else:
            return PadDirection.INPUT
    
    def get_output_value(self) -> int:
        """Get output value (0 or 1) for output pads"""
        return 1 if (self.dw0 & self.DW0_GPIOTXSTATE_MASK) else 0
    
    def get_reset_config(self) -> PadReset:
        """Extract reset domain configuration from DW1"""
        reset_val = (self.dw1 & self.DW1_PADRSTCFG_MASK) >> 30
        try:
            return PadReset(reset_val)
        except ValueError:
            return PadReset.PLTRST
    
    def get_termination(self) -> PadPull:
        """Extract termination/pull configuration from DW1"""
        term_val = (self.dw1 & self.DW1_TERM_MASK) >> 10
        try:
            return PadPull(term_val)
        except ValueError:
            return PadPull.NONE
    
    def has_interrupt(self) -> bool:
        """Check if pad has interrupt routing enabled"""
        return ((self.dw0 & self.DW0_GPIROUTIOXAPIC_MASK) != 0 or
                (self.dw0 & self.DW0_GPIROUTSCI_MASK) != 0 or
                (self.dw0 & self.DW0_GPIROUTSMI_MASK) != 0 or
                (self.dw0 & self.DW0_GPIROUTNMI_MASK) != 0)
    
    def get_interrupt_type(self) -> str:
        """Determine interrupt routing type"""
        if self.dw0 & self.DW0_GPIROUTIOXAPIC_MASK:
            return 'APIC'
        elif self.dw0 & self.DW0_GPIROUTSCI_MASK:
            return 'SCI'
        elif self.dw0 & self.DW0_GPIROUTSMI_MASK:
            return 'SMI'
        elif self.dw0 & self.DW0_GPIROUTNMI_MASK:
            return 'NMI'
        return 'NONE'
    
    def to_dict(self) -> Dict:
        """Convert to dictionary representation"""
        return {
            'dw0': f'0x{self.dw0:08x}',
            'dw1': f'0x{self.dw1:08x}',
            'mode': self.get_pad_mode().name,
            'direction': self.get_direction().name if self.get_pad_mode() == PadMode.GPIO else 'N/A',
            'output_value': self.get_output_value() if self.get_direction() == PadDirection.OUTPUT else None,
            'reset': self.get_reset_config().name,
            'termination': self.get_termination().name,
            'interrupt': self.get_interrupt_type(),
        }


def get_pad_name(group: str, index: int) -> str:
    """
    Generate pad name from group and index.
    
    Args:
        group: GPIO group name (e.g., 'GPP_B')
        index: Pad index within group
    
    Returns:
        Full pad name (e.g., 'GPP_B12')
    """
    # Special handling for virtual GPIOs
    if group.startswith('VGPIO'):
        if group == 'VGPIO':
            return f'VGPIO_{index}'
        elif group == 'VGPIO_0':
            # USB OC virtual GPIOs
            return f'VGPIO_USB_{index}'
        elif group == 'VGPIO_PCIE':
            return f'VGPIO_PCIE_{index}'
    
    # Standard GPIO groups
    return f'{group}{index}'


def find_group_for_pad(pad_number: int, community: int) -> Optional[Tuple[str, int]]:
    """
    Find the GPIO group and local index for a given pad number within a community.
    
    Args:
        pad_number: Absolute pad number within the community
        community: Community number
    
    Returns:
        Tuple of (group_name, local_index) or None if not found
    """
    for group_name, info in GPIO_GROUPS.items():
        if info['community'] != community:
            continue
        
        if info['pad_start'] <= pad_number < info['pad_start'] + info['pad_count']:
            local_index = pad_number - info['pad_start']
            return (group_name, local_index)
    
    return None


# Known UEFI module names/patterns that typically contain GPIO configuration
GPIO_MODULE_PATTERNS = [
    'Gpio',
    'GPIO',
    'PchInit',
    'PchGpio',
    'SiliconInit',
    'GpioInit',
    'PlatformGpio',
]

# Known FSP GUIDs for Alder Lake (if available from public FSP releases)
# These can be used to identify FSP-S modules that contain GPIO tables
KNOWN_FSP_GUIDS = [
    # Add known GUIDs here as they're discovered
]

[File Ends] platforms/alderlake.py

[File Begins] requirements.txt
# Python dependencies for bios2gpio
# Currently minimal - may expand as tool evolves

[File Ends] requirements.txt

[File Begins] task.md.resolved
# GPIO Extraction Tool Development

## Phase 1: Planning & Research
- [ ] Analyze existing coreboot GPIO configurations for Z690
- [ ] Research UEFI module structure for GPIO tables
- [ ] Define Z690 GPIO pad configuration struct layout
- [ ] Create verification methodology using MSI Z690 as reference

## Phase 2: Core Tool Development
- [x] Build UEFI firmware extraction pipeline
  - [x] IFD region splitting
  - [x] UEFI module extraction
  - [x] Module classification and filtering
- [x] Implement GPIO table detection
  - [x] Name-based module filtering
  - [x] Binary pattern scanning for pad structures
  - [x] Signature-based table identification
- [x] Create Z690 GPIO struct parser
  - [x] Define pad configuration data structures
  - [x] Implement bitfield decoding (DW0/DW1 registers)
  - [x] Map to logical GPIO properties

## Phase 3: Output Generation
- [x] Build coreboot macro generator
  - [x] Generate GPIO_PAD_CFG_* macros
  - [x] Format output matching coreboot style
- [x] Create JSON intermediate format
- [/] Implement comparison/verification tools

## Phase 4: Verification
- [ ] Extract GPIO from MSI Z690 vendor BIOS
- [ ] Compare against coreboot's MSI Z690 gpio.h
- [ ] Calculate match percentage and analyze differences
- [ ] Document findings and refine extraction

## Phase 5: ASRock Application
- [ ] Apply tool to ASRock Z690 Steel Legend BIOS
- [ ] Generate gpio.h for ASRock board
- [ ] Perform sanity checks on extracted configuration

[File Ends] task.md.resolved

[File Begins] test_gpio.h
/* SPDX-License-Identifier: GPL-2.0-only */

/* Generated by bios2gpio tool */

#include <soc/gpio.h>

static const struct pad_config gpio_table[] = {
	/* ------- GPIO Group GPP_I ------- */

	/* GPP_I0 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I0, NONE, PWROK, OFF, ACPI),
	/* GPP_I1 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I1, NONE, PWROK, OFF, ACPI),
	/* GPP_I10 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I10, NONE, PWROK, OFF, ACPI),
	/* GPP_I11 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I11, NONE, PWROK, OFF, ACPI),
	/* GPP_I12 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I12, DN_5K, PWROK, OFF, ACPI),
	/* GPP_I13 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I13, NONE, PWROK, OFF, ACPI),
	/* GPP_I14 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I14, NONE, PWROK, OFF, ACPI),
	/* GPP_I15 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I15, DN_5K, PWROK, OFF, ACPI),
	/* GPP_I16 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I16, NONE, PWROK, OFF, ACPI),
	/* GPP_I17 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I17, NONE, PWROK, OFF, ACPI),
	/* GPP_I18 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I18, DN_5K, PWROK, OFF, ACPI),
	/* GPP_I19 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I19, NONE, PWROK, OFF, ACPI),
	/* GPP_I2 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I2, DN_5K, PWROK, OFF, ACPI),
	/* GPP_I3 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I3, NONE, PWROK, OFF, ACPI),
	/* GPP_I4 - NF6 */
	PAD_CFG_NF(GPP_I4, NONE, PWROK, NF6),
	/* GPP_I5 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I5, NONE, PWROK, OFF, ACPI),
	/* GPP_I6 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I6, DN_5K, PWROK, OFF, ACPI),
	/* GPP_I7 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I7, NONE, PWROK, OFF, ACPI),
	/* GPP_I8 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I8, NONE, PWROK, OFF, ACPI),
	/* GPP_I9 - GPIO */
	PAD_CFG_GPI_TRIG_OWN(GPP_I9, DN_5K, PWROK, OFF, ACPI),
};

[File Ends] test_gpio.h

[File Begins] test_platform.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
Simple test to verify platform definitions and GPIO parsing.
"""

import sys
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent))

from platforms.alderlake import AlderLakeGpioPadConfig, get_pad_name, GPIO_GROUPS

def test_pad_config_parsing():
    """Test GPIO pad configuration parsing"""
    print("Testing GPIO pad configuration parsing...")
    
    # Example DW0/DW1 values from a typical GPIO output pad
    # GPO, output=1, PLTRST, no termination
    dw0 = 0x00000001  # TX state = 1, mode = GPIO
    dw1 = 0x80000000  # Reset = PLTRST (10b << 30)
    
    # Create test data
    test_data = dw0.to_bytes(4, 'little') + dw1.to_bytes(4, 'little')
    
    # Parse
    config = AlderLakeGpioPadConfig(test_data)
    
    print(f"  DW0: 0x{config.dw0:08x}")
    print(f"  DW1: 0x{config.dw1:08x}")
    print(f"  Mode: {config.get_pad_mode().name}")
    print(f"  Direction: {config.get_direction().name}")
    print(f"  Output value: {config.get_output_value()}")
    print(f"  Reset: {config.get_reset_config().name}")
    print(f"  Termination: {config.get_termination().name}")
    
    assert config.get_pad_mode().name == 'GPIO'
    assert config.get_output_value() == 1
    print("  ✓ Basic parsing works\n")

def test_pad_naming():
    """Test pad name generation"""
    print("Testing pad name generation...")
    
    # Test standard GPIO groups
    assert get_pad_name('GPP_B', 0) == 'GPP_B0'
    assert get_pad_name('GPP_B', 12) == 'GPP_B12'
    assert get_pad_name('GPP_D', 5) == 'GPP_D5'
    
    # Test virtual GPIOs
    assert get_pad_name('VGPIO', 0) == 'VGPIO_0'
    assert get_pad_name('VGPIO_PCIE', 10) == 'VGPIO_PCIE_10'
    
    print("  ✓ Pad naming works\n")

def test_gpio_groups():
    """Test GPIO group definitions"""
    print("Testing GPIO group definitions...")
    
    # Check some key groups exist
    assert 'GPP_A' in GPIO_GROUPS
    assert 'GPP_B' in GPIO_GROUPS
    assert 'GPP_D' in GPIO_GROUPS
    assert 'GPD' in GPIO_GROUPS
    
    # Check group structure
    gpp_b = GPIO_GROUPS['GPP_B']
    assert gpp_b['community'] == 1
    assert gpp_b['pad_count'] == 24
    
    print(f"  Total GPIO groups defined: {len(GPIO_GROUPS)}")
    print(f"  Communities: {sorted(set(g['community'] for g in GPIO_GROUPS.values()))}")
    print("  ✓ GPIO groups defined correctly\n")

def main():
    print("=" * 60)
    print("bios2gpio Platform Definition Tests")
    print("=" * 60)
    print()
    
    try:
        test_pad_config_parsing()
        test_pad_naming()
        test_gpio_groups()
        
        print("=" * 60)
        print("All tests passed! ✓")
        print("=" * 60)
        return 0
        
    except AssertionError as e:
        print(f"\n✗ Test failed: {e}")
        return 1
    except Exception as e:
        print(f"\n✗ Error: {e}")
        import traceback
        traceback.print_exc()
        return 1

if __name__ == '__main__':
    sys.exit(main())

[File Ends] test_platform.py

[File Begins] test_report.txt
GPIO Configuration Summary
============================================================
Platform: alderlake
Total Pads: 20

Pad Modes:
  GPIO: 19
  NF6: 1

GPIO Directions:
  INPUT: 19

Detailed Pad List:
------------------------------------------------------------

GPP_I:
  GPP_I0               GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I1               GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I10              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I11              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I12              GPIO     INPUT    reset=PWROK    term=DN_5K
  GPP_I13              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I14              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I15              GPIO     INPUT    reset=PWROK    term=DN_5K
  GPP_I16              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I17              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I18              GPIO     INPUT    reset=PWROK    term=DN_5K
  GPP_I19              GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I2               GPIO     INPUT    reset=PWROK    term=DN_5K
  GPP_I3               GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I4               NF6      N/A      reset=PWROK    term=NONE
  GPP_I5               GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I6               GPIO     INPUT    reset=PWROK    term=DN_5K
  GPP_I7               GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I8               GPIO     INPUT    reset=PWROK    term=NONE
  GPP_I9               GPIO     INPUT    reset=PWROK    term=DN_5K
[File Ends] test_report.txt

[File Begins] uefi_extractor.py
#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0-only

"""
UEFI firmware extraction module.

Handles extraction of UEFI modules from vendor BIOS images using
external tools (ifdtool, UEFIExtract).
"""

import os
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)


class UEFIExtractor:
    """Extracts and organizes UEFI modules from vendor BIOS images"""
    
    def __init__(self, bios_image: str, work_dir: Optional[str] = None):
        """
        Initialize UEFI extractor.
        
        Args:
            bios_image: Path to vendor BIOS image file
            work_dir: Working directory for extraction (temp dir if None)
        """
        self.bios_image = Path(bios_image)
        if not self.bios_image.exists():
            raise FileNotFoundError(f"BIOS image not found: {bios_image}")
        
        if work_dir:
            self.work_dir = Path(work_dir)
            self.work_dir.mkdir(parents=True, exist_ok=True)
            self.temp_dir = None
        else:
            self.temp_dir = tempfile.mkdtemp(prefix='bios2gpio_')
            self.work_dir = Path(self.temp_dir)
        
        self.bios_region_path: Optional[Path] = None
        self.extracted_modules_dir: Optional[Path] = None
        self.modules: List[Dict] = []
    
    def __del__(self):
        """Cleanup temporary directory if created"""
        if self.temp_dir and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
    
    def check_dependencies(self) -> bool:
        """
        Check if required external tools are available.
        
        Returns:
            True if all dependencies are available
        """
        # Check for ifdtool
        ifdtool_path = shutil.which('ifdtool')
        if not ifdtool_path:
            # Try coreboot util path
            coreboot_root = Path(__file__).parent.parent.parent
            ifdtool_path = coreboot_root / 'util' / 'ifdtool' / 'ifdtool'
            if not ifdtool_path.exists():
                logger.error("ifdtool not found. Please build it in util/ifdtool/")
                return False
        
        # Check for UEFIExtract
        uefi_extract = shutil.which('UEFIExtract')
        if not uefi_extract:
            logger.warning("UEFIExtract not found in PATH. Will attempt to use alternative methods.")
            # UEFIExtract is optional - we can work with raw BIOS region
        
        return True
    
    def extract_bios_region(self) -> Path:
        """
        Extract BIOS region from IFD-formatted image using ifdtool.
        
        Returns:
            Path to extracted BIOS region
        """
        logger.info(f"Extracting BIOS region from {self.bios_image}")
        
        # Find ifdtool
        ifdtool_path = shutil.which('ifdtool')
        if not ifdtool_path:
            coreboot_root = Path(__file__).parent.parent.parent
            ifdtool_path = str(coreboot_root / 'util' / 'ifdtool' / 'ifdtool')
        
        # Run ifdtool to extract regions
        output_prefix = self.work_dir / 'flashregion'
        cmd = [ifdtool_path, '-x', str(self.bios_image)]
        
        try:
            result = subprocess.run(
                cmd,
                cwd=str(self.work_dir),
                capture_output=True,
                text=True,
                check=True
            )
            logger.debug(f"ifdtool output: {result.stdout}")
            
            # ifdtool creates files like flashregion_3_bios.bin
            bios_files = list(self.work_dir.glob('flashregion_*_bios.bin'))
            if not bios_files:
                # Maybe it's already a BIOS region without IFD
                logger.warning("No BIOS region extracted, assuming input is raw BIOS region")
                self.bios_region_path = self.bios_image
            else:
                self.bios_region_path = bios_files[0]
                logger.info(f"BIOS region extracted to {self.bios_region_path}")
            
            return self.bios_region_path
            
        except subprocess.CalledProcessError as e:
            logger.warning(f"ifdtool failed: {e.stderr}")
            logger.info("Assuming input is raw BIOS region without IFD")
            self.bios_region_path = self.bios_image
            return self.bios_region_path
    
    def extract_uefi_modules(self) -> Path:
        """
        Extract UEFI modules from BIOS region using UEFIExtract.
        
        Returns:
            Path to directory containing extracted modules
        """
        if not self.bios_region_path:
            self.extract_bios_region()
        
        logger.info(f"Extracting UEFI modules from {self.bios_region_path}")
        
        uefi_extract = shutil.which('UEFIExtract')
        if not uefi_extract:
            logger.warning("UEFIExtract not available, will work with raw BIOS region")
            self.extracted_modules_dir = self.work_dir / 'raw'
            self.extracted_modules_dir.mkdir(exist_ok=True)
            # Copy BIOS region to work dir for analysis
            shutil.copy(self.bios_region_path, self.extracted_modules_dir / 'bios_region.bin')
            return self.extracted_modules_dir
        
        # Create output directory for extracted modules
        self.extracted_modules_dir = self.work_dir / 'uefi_extracted'
        self.extracted_modules_dir.mkdir(exist_ok=True)
        
        # Run UEFIExtract
        cmd = [uefi_extract, str(self.bios_region_path), 'all']
        
        try:
            result = subprocess.run(
                cmd,
                cwd=str(self.extracted_modules_dir),
                capture_output=True,
                text=True,
                check=True
            )
            logger.debug(f"UEFIExtract output: {result.stdout}")
            logger.info(f"UEFI modules extracted to {self.extracted_modules_dir}")
            
        except subprocess.CalledProcessError as e:
            logger.error(f"UEFIExtract failed: {e.stderr}")
            raise
        
        return self.extracted_modules_dir
    
    def find_modules(self, patterns: List[str]) -> List[Dict]:
        """
        Find UEFI modules matching given name patterns.
        
        Args:
            patterns: List of name patterns to search for
        
        Returns:
            List of dicts with module info (path, name, size)
        """
        if not self.extracted_modules_dir:
            self.extract_uefi_modules()
        
        matching_modules = []
        
        # Search for files matching patterns
        for pattern in patterns:
            # Case-insensitive search
            pattern_lower = pattern.lower()
            
            # Walk through extracted directory
            for root, dirs, files in os.walk(self.extracted_modules_dir):
                for file in files:
                    file_lower = file.lower()
                    if pattern_lower in file_lower:
                        file_path = Path(root) / file
                        module_info = {
                            'path': file_path,
                            'name': file,
                            'size': file_path.stat().st_size,
                            'pattern': pattern,
                        }
                        matching_modules.append(module_info)
                        logger.debug(f"Found module: {file} (matched pattern '{pattern}')")
        
        self.modules = matching_modules
        logger.info(f"Found {len(matching_modules)} modules matching patterns")
        
        return matching_modules
    
    def get_bios_region(self) -> Path:
        """
        Get path to BIOS region (extracting if necessary).
        
        Returns:
            Path to BIOS region file
        """
        if not self.bios_region_path:
            self.extract_bios_region()
        return self.bios_region_path
    
    def get_all_binary_files(self) -> List[Path]:
        """
        Get all binary files from extracted modules.
        
        Returns:
            List of paths to binary files
        """
        if not self.extracted_modules_dir:
            self.extract_uefi_modules()
        
        binary_files = []
        for root, dirs, files in os.walk(self.extracted_modules_dir):
            for file in files:
                file_path = Path(root) / file
                # Look for .bin, .efi, .pe32, .raw files
                if file_path.suffix.lower() in ['.bin', '.efi', '.pe32', '.raw', '']:
                    binary_files.append(file_path)
        
        return binary_files

[File Ends] uefi_extractor.py


<-- File Content Ends

